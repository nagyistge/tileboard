<!DOCTYPE html>
<meta charset="utf-8">
<style>
.board {
  border-collapse: collapse;
}

.board td {
  width: 64px;
  height: 64px;
  background: black;
  border: 1px solid white;
  padding: 0;
}

.board img {
  width: 100%;
  height: 100%;
}

.js-moving {
  position: relative;
  transition-property: left, top;
  transition-duration: 1s, 1s;
}
</style>
<title>Tileboard</title>
<h1>Tileboard</h1>
<script>
var WIDTH = 8;
var HEIGHT = 8;

function getRandomChoice(arrayLike) {
  var index = getRandomInt(0, arrayLike.length-1);
  return arrayLike[index];
}

// Returns a random integer between min and max
// Using Math.round() will give you a non-uniform distribution!
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function activatePieces(table) {
  var observer = new MutationObserver(function(mutations) {
    var removed = [];
    
    mutations.forEach(function(m) {
      if (m.type == "attributes") {
        if (m.target.nodeName !== "IMG")
          return;
        var node = m.target;
        var newBehavior = node.getAttribute("data-behavior");
        var oldBehavior = m.oldValue;
        if (oldBehavior != newBehavior) {
          if (node.behavior) {
            node.behavior.tearDown();
            delete node.behavior;
          }
          if (newBehavior && newBehavior in PieceBehaviors) {
            node.behavior = new PieceBehaviors[newBehavior](node);
          }
        }
      } else {
        if (m.target.nodeName != "TD")
          return;
        if (m.removedNodes && m.removedNodes.length)
          removed = removed.concat([].slice.call(m.removedNodes));
        if (m.addedNodes && m.addedNodes.length) {
          [].slice.call(m.addedNodes).forEach(function(node) {
            var index = removed.indexOf(node);
            if (index != -1)
              removed.splice(index, 1);
          });
        }
      }
    });
    
    removed.forEach(function(node) {
      if (node.behavior) {
        node.behavior.tearDown();
        delete node.behavior;
      }
    });
  });
  
  observer.observe(table, {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ['data-behavior']
  });
  
  return observer;
}

function smoothifyMovement(table) {
  function endMovement() {
    if (this.classList.contains("js-moving")) {
      this.classList.remove("js-moving");
      this.style.left = null;
      this.style.top = null;
      ["style", "class"].forEach(function(attr) {
        if (this.hasAttribute(attr) && this.getAttribute(attr) === "")
          this.removeAttribute(attr);
      }, this);
    }
  }
  
  var observer = new MutationObserver(function(mutations) {
    var removed = [];
    var removedParents = [];

    mutations.forEach(function(m) {
      if (m.target.nodeName !== "TD")
        return;
      if (m.removedNodes && m.removedNodes.length)
        [].slice.call(m.removedNodes).forEach(function(node) {
          endMovement.call(node);
          removed.push(node);
          removedParents.push(m.target);
        });
      if (m.addedNodes && m.addedNodes.length) {
        [].slice.call(m.addedNodes).forEach(function(node) {
          var index = removed.indexOf(node);
          if (index != -1) {
            var prevRect = removedParents[index].getBoundingClientRect();
            var currRect = m.target.getBoundingClientRect();
            node.style.left = (prevRect.left - currRect.left) + "px";
            node.style.top = (prevRect.top - currRect.top) + "px";
            node.classList.add("js-moving");

            setTimeout(function() {
              node.style.left = "0px";
              node.style.top = "0px";
              node.addEventListener("transitionend", endMovement);
            }, 50);
          }
        });
      }
    });
  });

  observer.observe(table, {
    subtree: true,
    childList: true
  });
  
  return observer;
}

var PieceBehaviors = {
  RandomMover: function(img) {
    this._img = img;
    this._interval = setInterval(this.randomMove.bind(this), 2000);
  }
};

PieceBehaviors.RandomMover.prototype = {
  randomMove: function() {
    var cell = this._img.parentNode;
    var table = cell.parentNode.parentNode;
    var randomRow = getRandomChoice(table.childNodes);
    var randomCell = getRandomChoice(randomRow.childNodes);
    if (randomCell === cell)
      return this.randomMove();
    var old = randomCell.replaceChild(this._img, randomCell.firstChild);
    cell.appendChild(old);
  },
  tearDown: function() {
    clearInterval(this._interval);
  }
};

window.addEventListener("DOMContentLoaded", function() {
  var table = document.createElement("table");

  table.classList.add("board");
  document.body.appendChild(table);

  for (var y = 0; y < HEIGHT; y++) {
    var row = document.createElement("tr");

    table.appendChild(row);
    
    for (var x = 0; x < WIDTH; x++) {
      var img = document.createElement("img");
      var td = document.createElement("td");
      var id = "tile" + x + 'x' + y;

      img.setAttribute("src", "empty.gif");
      td.appendChild(img);
      td.setAttribute("class", "normal");
      td.setAttribute("title", "this is " + id + ".");
      row.appendChild(td);
      window[id] = td;
    }
  }
  
  var smoothifyObserver = smoothifyMovement(table);
  var pieceBehaviorObserver = activatePieces(table);
  
  tile0x0.firstChild.setAttribute("data-behavior", "RandomMover");
  tile0x0.firstChild.src = "https://developer.cdn.mozilla.net/media/img/mdn-logo-sm.png";
  window.mdntile = tile0x0.firstChild;
}, false);
</script>
